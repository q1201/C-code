#define _CRT_SECURE_NO_WARNINGS 1

# include <stdio.h>

//注：单目操作符只有一个操作数

int main()
{
	// ! 逻辑反操作
	int flag = 5;            //5为真        
	printf("%d\n", !flag);   //! 逻辑反，输出结果为0

	int fly = 0;             //0为假
	printf("%d\n", !fly);    //! 逻辑反，输出结果为1

	printf("%d\n", sizeof(short));


	//sizeof() 计算出操作数的类型长度，以字节为单位
	short a = 10;
	int b = 5;

	printf("a = %d\n", sizeof(a = b + 7));  //输出结果为 a = 2, 短整型占2个字节
	printf("a = %d\n", a);   //输出结果为 a = 10,因为sizeof()中的表达式不参与运算


	// ~ 对一个数的二进制位(补码)按位取反
	int x = -1;           //变量以补码的形式在计算机的内存中存储
	//100000000000000000000000000000001 - 原码
	//111111111111111111111111111111110 - 反码
	//111111111111111111111111111111111 - 补码
	int y = ~x;
	//000000000000000000000000000000000  
	printf("y = %d\n", y);    //输出结果为 y = 0

	int z = -15;
	//100000000000000000000000000001111 - 原码
	//111111111111111111111111111110000 - 反码
	//111111111111111111111111111110001 - 补码
	int t = ~z;
	//000000000000000000000000000001110
	printf("t = %d\n", t);    //输出结果为 t = 14


    //应用：把变量二进制位的第五位取反,再还原
	int q = 13;
	//00000000000000000000000000001101 - 正数原码、反码、补码都一样

	int w = q | 1 << 4;
	//00000000000000000000000000010000 - 1 << 4
	//00000000000000000000000000011101 - w

	int e = w & ~(1 << 4);
	//11111111111111111111111111101111 - ~(1 << 4)
	//00000000000000000000000000001101 - e == q
	printf("e = %d\n", e);

	int r = w ^ (1 << 4);
	//00000000000000000000000000001101 - r == q
	printf("r = %d\n", r);


	//& - 取地址操作符
	//* - 解引用操作符/间接访问操作符
	int h = 10;
	printf("%p\n", &h);      //输出结果为 0093F894

	int * v = &h;
	*v = 20;

	printf("h = %d\n", h);   //输出结果为 20
	printf("%p\n", &h);      //输出结果为 0093F894


	//() - 强制类型转换
	int p = (int)3.14;       //3.14默认为double类型，强制类型转换后变为整型

	return 0;
}